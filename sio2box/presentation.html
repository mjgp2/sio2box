<!DOCTYPE html>
<html>
  <head>
    <title>Fun with bytecode</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Fun with bytecode

---

# Agenda

1. Run through some theory

---

# Java Agents

WTF is a Java agent?

> An agent is just an interceptor in front of your main method, executed in the same JVM and loaded by the same system classloader, and governed by the same security policy and context.

```
public static void premain(String agentArgs, Instrumentation inst);

Manifest-Version: 1.0
Premain-Class: my.package.MyJavaAgent
Boot-Class-Path: some-dependency.jar

-javaagent:<jarpath>[=<options>]
load Java programming language agent, see java.lang.instrument
```

Basically just a way of hooking into the `Instrumentation` class :)

---

# Getting funky with Instrumentation

Lets you hook in `ClassFileTransformer` instances - which are what they sound like.

```
    byte[]
    transform(  ClassLoader         loader,
                String              className,
                Class               classBeingRedefined,
                ProtectionDomain    protectionDomain,
                byte[]              classfileBuffer)
        throws IllegalClassFormatException;
```

But what's in the byte arrays?

---

# Class structure

<img src="http://s14.postimg.org/p03b4hsox/Bytecode.png" alt="" style="width: 75%;">

---

# Bytecode

> "Understanding bytecode and what bytecode is likely to be generated by a Java compiler helps the Java programmer in the same way that knowledge of assembly helps the C or C++ programmer."

When a JVM loads a class file, it gets one stream of bytecodes for each method in the class that are interpreted or JIT compiled.

One byte opcode (action) and its operands. Opcodes have mnemonics.

The Java stack is a last-in, first-out stack of 32-bit slots. Because each slot in the stack occupies 32 bits, all local variables occupy at least 32 bits - even a byte.

> "We chose a stack organization so that it would be easy to emulate the machine efficiently on machines with few or irregular registers such as the Intel 486."

---

# Disassembling bytecode

```
// Bytecode stream: 03 3b 84 00 01 1a 05 68 3b a7 ff f9

iconst_0      // 03        &lt;= push the int value 0 onto the stack
istore_0      // 3b        &lt;= pop one, store in local var 0
iinc 0, 1     // 84 00 01  &lt;= increment local var 0 by 1
iload_0       // 1a        &lt;= push local variable 0 on the stack
iconst_2      // 05        &lt;= push the int value 2 onto the stack
imul          // 68        &lt;= pop two, push x*y onto the stack
istore_0      // 3b        &lt;= pop one, store in local var 0
```

---

# Javassist: sub-optimal but easy

```
  public byte[] transform(ClassLoader loader, String className, Class classBeingRedefined, 
    ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {

     pool.insertClassPath(new ByteArrayClassPath(className, classfileBuffer));
     CtClass cclass = pool.get(className.replaceAll("/", "."));
     if (cclass.isFrozen()) {
       return null; // use uninstrumented class, already processed
     }
     for (CtMethod currentMethod : cclass.getDeclaredMethods()) {
       currentMethod.insertBefore("System.err.println('foo');");
     }
     return cclass.toBytecode();
```

* insertBefore(): insert the specified code before the method is executed
* insertAfter(): insert byte code at the end of the method body
* insertAt(): inserts byte code at the specified line number in the method
* addParameter(): adds a new parameter to the method signature
* addLocalVariable(): adds a new local variable to the method
* addCatch(): adds a catch block for the specified exception type to the method
* setBody(): sets the bytecode for the entire body of the method

Not so good as a learning exercise :)

---

# ASM: total control, but like writing assembler.

Event model, similar to SAX.

Extend abstract class:

```
ClassVisitor {
  void visit(int version, int access, String name, String signature, String superName, 
    String[] interfaces)
  void visitSource(String source, String debug)
  void visitOuterClass(String owner, String name, String desc)
  AnnotationVisitor visitAnnotation(String desc, boolean visible)
  AnnotationVisitor visitTypeAnnotation(int typeRef,TypePath typePath, String desc, 
    boolean visible)
  void visitAttribute(Attribute attr)
  void visitInnerClass(String name, String outerName, String innerName, int access)
  FieldVisitor visitField(int access, String name, String desc, String signature, 
    Object value)
  MethodVisitor visitMethod(int access, String name, String desc, String signature, 
    String[] exceptions)
  void visitEnd()
}
```

---

... and hook in

```
public byte[] transform(ClassLoader loader, String className,
    Class classBeingRedefined, ProtectionDomain protectionDomain,
    byte[] classfileBuffer) throws IllegalClassFormatException {
                                  
    ClassReader cr = new ClassReader(classfileBuffer);
    ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_FRAMES|ClassWriter.COMPUTE_MAXS);
    cr.accept(cw, 0);
    return cw.toByteArray();
}
```

--- sio2box (_sandbox_)

Add annotations to classes (SiO2Class) and methods (SiO2Method) to limit the total amount of memory allocated by untrusted code.

Don't take GC into account, interested in memory churn - could use `ReferenceQueue` if we were.

Let's look at some code!

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>