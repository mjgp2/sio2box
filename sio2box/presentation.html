<!DOCTYPE html>
<html>
  <head>
    <title>Fun with bytecode</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Fun with bytecode

---

# Who the hell are you?

* Programmer
* Entrepeneur
* CTO of import.io
* Geek
* Ex-mathematician
* Long-suffering Java user (yay, lambdas!)
* Proud father of two :)

---

# So what's the plan?

1. What?
1. Why?
1. How?
1. Codez
1. Q&A
1. Beer!

---

# Some JVM internals

Do you know how the JVM does its magic?

---

## Per JVM

* Heap for objects
* PermGen/Metaspace

## Per Thread

* PC (Program Counter) tracks instruction position in a register
* Stack (as in trace) of Frames (method invocations)
* Native stack

## Per frame

* Local variable 32bit array ([0]=this)
* Operand 32bit stack
* Constant pool reference for the class

---

# Operand stack

The Java stack is a last-in, first-out stack of 32-bit slots. Because each slot in the stack occupies 32 bits, all stack variables occupy at least 32 bits - even a byte. Longs/Doubles take 2 slots.

> "We chose a stack organization so that it would be easy to emulate the machine efficiently on machines with few or irregular registers such as the Intel 486."

# Local variable array

Zero-indexed, 32 bit slots.

---

# Bytecode

> "Understanding bytecode and what bytecode is likely to be generated by a Java compiler helps the Java programmer in the same way that knowledge of assembly helps the C or C++ programmer."

When a JVM loads a class file, it gets a stream of bytecodes that represent the logic for each method that are interpreted or JIT compiled.

One byte opcode (mnemonics, action) and its operands.

---

# Disassembling bytecode

```java
public static int factorial(int x) {
    int y = 1;
    for ( int z=2; z<=x; z++) y*=z;
    return y;
}
```

PC keeps track of current position...

```

 0 iconst_1            [1]  [x]
 1 istore_1            []   [x,1]
 2 iconst_2            [2]  [x,1]
 3 istore_2            []   [x,1,2]
 4 iload_2             [2]  [x,1,2]
 5 iload_0             [x,2][x,1,2]
 6 if_icmpgt 19 (+13)  []   [x,1,2]
 9 iload_1             [1]  [x,1,2] 
10 iload_2             [2,1]
11 imul                [2]  [x,1,2]
12 istore_1            []   [x,2,2]
13 iinc 2 by 1         []   [x,2,3]
16 goto 4 (-12)        []   [x,2,3]
19 iload_1             [y]  [x,y,z]
20 ireturn             []   [x,y,z]

```

---

# Method signatures


```
V - void
B – byte
C – char
D – double
F – float
I – int
J – long
S – short
V – void
Z – boolean
[ – array of the thing following the bracket
L [class name] ; – instance of this class, with dots becoming slashes
( [args] ) [return type] – method signature
```

For example:

`public int foo(String bar, long[][] baz)`

becomes

`(Ljava/lang/String;[[J)I`

---

# What is bytecode weaving?

Changing byte code for a class either up front or dynamically at run-time.

---

# Why should I want to weave bytecode?

* Proxy creation
* Aspect-orientated programming
* Logging
* Sandboxing
* Code coverage
* Adding in features like co-routines
* Anything else you can dream up :)

---

# How to weave

WTF is a Java agent?

> An agent is just an interceptor in front of your main method, executed in the same JVM and loaded by the same system classloader, and governed by the same security policy and context.

Need a class with a `premain` method:

```
public static void premain(String agentArgs, Instrumentation inst);
```

... and some special MANIFEST.MF lines:
```
Manifest-Version: 1.0
Premain-Class: my.package.MyJavaAgent
Boot-Class-Path: some-dependency.jar
```

... a command line option:
```
-javaagent:<jarpath>[=<options>]
load Java programming language agent, see java.lang.instrument
```

... to hook into the `Instrumentation` class

---

# Getting funky with Instrumentation

Lets you hook in `ClassFileTransformer` instances - which are what they sound like.

```
    byte[]
    transform(  ClassLoader         loader,
                String              className,
                Class               classBeingRedefined,
                ProtectionDomain    protectionDomain,
                byte[]              classfileBuffer)
        throws IllegalClassFormatException;
```

But what's in the byte arrays?

---

# Class structure

<img src="http://s14.postimg.org/p03b4hsox/Bytecode.png" alt="" style="width: 75%;">

---

# How do you modify the bytes?

* Manually (Super scary)
* Javassist
* ASM
* Other libraries may be available... :)

---

# Javassist: a quick aside

It'll parse Java source strings - no bytecode required.

```
public byte[] transform(ClassLoader loader, String className, Class classBeingRedefined, 
  ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {

   pool.insertClassPath(new ByteArrayClassPath(className, classfileBuffer));
   CtClass cclass = pool.get(className.replaceAll("/", "."));
   if (cclass.isFrozen()) {
     return null; // use uninstrumented class, already processed
   }
   for (CtMethod currentMethod : cclass.getDeclaredMethods()) {
     currentMethod.insertBefore("System.err.println('foo');");
   }
   return cclass.toBytecode();
}
```

Easy, but not the quickest.

Not so good as a learning exercise either :)

---

# ASM: total control, but like writing assembler.

Event model, similar to SAX.

Extend abstract class:

```java
class ClassVisitor {
  void visit(int version, int access, String name, String signature, String superName, 
    String[] interfaces)
  void visitSource(String source, String debug)
  void visitOuterClass(String owner, String name, String desc)
  AnnotationVisitor visitAnnotation(String desc, boolean visible)
  AnnotationVisitor visitTypeAnnotation(int typeRef,TypePath typePath, String desc, 
    boolean visible)
  void visitAttribute(Attribute attr)
  void visitInnerClass(String name, String outerName, String innerName, int access)
  FieldVisitor visitField(int access, String name, String desc, String signature, 
    Object value)
  MethodVisitor visitMethod(int access, String name, String desc, String signature, 
    String[] exceptions)
  void visitEnd()
}
```


---

# and hook in

to your `ClassFileTransformer`

```java
public byte[] transform(ClassLoader loader, String className,
    Class classBeingRedefined, ProtectionDomain protectionDomain,
    byte[] classfileBuffer) throws IllegalClassFormatException {
                                  
    ClassReader cr = new ClassReader(classfileBuffer);
    ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_FRAMES);
    cr.accept(cw, 0);
    return cw.toByteArray();
}
```

Easy!

---


# sio2box

A memory sandbox that counts allocations.

Add annotations to classes (SiO2Class) and methods (SiO2Method) to limit the total amount of memory allocated by untrusted code.

Don't take GC into account, interested in memory churn - could use `ReferenceQueue` if we were.

Tracks:

* Array.newInstance
* type[].clone
* Object instantiation
* new type[] - ANEWARRAY, NEWARRAY, MULTIANEWARRAY
* Object.clone
* ArrayList.clone (TODO)


---

# Quick example

Pass through a `MemoryStore` object as the first argument (this is a convention).

```
MemoryStore memoryStore = new MemoryStore(maxMemory);
myMethod(memoryStore, arg0, arg1);
```

Annotate the class and method:

```
@SiO2Class
public class MyClass {

  @SiO2Method
  public void myMethod(MemoryStore m, String arg0, Object arg1) {
      ...
  }
}
```

If more memory is allocated than you specify, a `MemoryExceededException` exception is thrown.

---

# Code!
    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>